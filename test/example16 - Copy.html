<!DOCTYPE html>
<html>
<head>
    <title>Example 16</title>
    <meta charset="utf-8"/>
    <style>
        canvas,#con {
            width: 100%;
            height: 100%;
        }

        body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        html, body {
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="con">
        <canvas id="surface"></canvas>
    </div>
<script src="../src/noc.engine.latest.js"></script>

<script>
    
    function generateTexture() {
        var canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 64;
        var context = canvas.getContext('2d');
        context.fillStyle = '#ffffff';
        context.fillRect(0, 0, 32, 64);
        for (var y = 2; y < 64; y += 2) {
            for (var x = 0; x < 32; x += 2) {
                var value = Math.floor(Math.random() * 64);
                context.fillStyle = 'rgb(' + [value, value, value].join(',') + ')';
                context.fillRect(x, y, 2, 1);
            }
        }

        var canvas2 = document.createElement('canvas');
        canvas2.width = 512;
        canvas2.height = 1024;
        var context = canvas2.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.webkitImageSmoothingEnabled = false;
        context.mozImageSmoothingEnabled = false;
        context.drawImage(canvas, 0, 0, canvas2.width, canvas2.height);
        return canvas2;
    };

    var quad = function (o) {
        var dX = o.x;
        var dZ = o.z;
        var dY = o.y;

      

        var mesh = [
            new Noc.Point3D(dX-10,dY-10,dZ),
            new Noc.Point3D(dX + 10, dY - 10, dZ),
            new Noc.Point3D(dX - 10, dY + 10, dZ),
            new Noc.Point3D(dX + 10, dY + 10, dZ),

            new Noc.Point3D(dX - 10, dY - 10, dZ+100),
            new Noc.Point3D(dX + 10, dY - 10, dZ+100),
            new Noc.Point3D(dX - 10, dY + 10, dZ+100),
            new Noc.Point3D(dX + 10, dY + 10, dZ+100)


        ];
        mesh.forEach(function(m) {
            m.scale(0.014);
        });
        return mesh;
    };

    var buildings = function (n) {
        var buildingMeshs = [];
        for (var i = 0; i < n; i++) {
            // put a random position

           
          //  buildingMesh.scale(0.01);
            // put a random rotation
         //   buildingMesh.rotation.y = Math.random() * Math.PI * 2;
            // put a random scale
         //   buildingMesh.scale.x = Math.random() * Math.random() * Math.random() * Math.random() * 50 + 10;
          //  buildingMesh.scale.y = (Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;
          //  buildingMesh.scale.z = buildingMesh.scale.x

          //  // establish the base color for the buildingMesh
          //  var value = 1 - Math.random() * Math.random();
          ////  var baseColor = new THREE.Color().setRGB(value + Math.random() * 0.1, value, value + Math.random() * 0.1);
          //  // set topColor/bottom vertexColors as adjustement of baseColor
          //  var topColor = baseColor.clone().multiply(light);
          //  var bottomColor = baseColor.clone().multiply(shadow);
          //  // set .vertexColors for each face
          //  var geometry = buildingMesh.geometry;

            //for (var j = 0, jl = geometry.faces.length; j < jl; j++) {
            //    if (j === 2) {
            //        // set face.vertexColors on root face
            //        geometry.faces[j].vertexColors = [baseColor, baseColor, baseColor, baseColor];
            //    } else {
            //        // set face.vertexColors on sides faces
            //        geometry.faces[j].vertexColors = [topColor, bottomColor, bottomColor, topColor];
            //    }
            //}

            // merge it with cityGeometry - very important for performance
            //   THREE.GeometryUtils.merge(cityGeometry, buildingMesh);

            var buildingMesh = new Noc.Point3D();


            buildingMesh.x = Math.floor(Math.random() * 200 - 100) * 10;
            buildingMesh.z = Math.floor(Math.random() * 200 - 100) * 10;
            buildingMesh.y = Math.random() * Math.PI * 2;

            buildingMeshs.push(new quad(buildingMesh));
        }
        return buildingMeshs;
    }

    var engine;
   
    document.addEventListener("DOMContentLoaded", function(evt) {

        var colors = [];
   

        engine = new Noc.Engine("#surface",null,document.querySelector("#con"));

        var sea = new Noc.Entity("sea", function(frame, tf, ts) {

            var state = this.state;
            var ctx = frame.ctx;
            var quads = state.m;

            var faces = [
                [0, 1, 2, 3],
                [1, 5, 6, 2],
                [5, 4, 7, 6],
                [4, 0, 3, 7],
                [0, 4, 5, 1],
                [3, 2, 6, 7]
            ];

            for (var i = 0; i < quads.length; i++) {
                var t = [];

                var q = quads[i];

                for (var vert = 0; vert < q.length; vert++) {
                    var v = q[vert];
                    var r = v.rotateY(this.state.angle);

                    var p = r.project(frame.width, frame.height, 1500, this.state.d);
                    t.push(p);
                }

                var avgZ = [];

                for (var ii = 0; ii < faces.length; ii++) {
                    var f = faces[ii];

                    avgZ[ii] = { "index": ii, "z": (t[f[0]].z + t[f[1]].z + t[f[2]].z + t[f[3]].z) / 4.0 };
                };

                avgZ.sort(function(a, b) {
                    return b.z - a.z;
                });

                for (var fi = 0; fi < faces.length; fi++) {
                    //  console.log(faces, fi);
                    var fa = faces[avgZ[fi].index];
                    //   var fa = faces[fi];

                    //  console.log(t[fa[0]].x, t[fa[0]].y);

                    ctx.fillStyle = "rgb(255,0,0)";
                    ctx.beginPath();
                    ctx.moveTo(t[fa[0]].x, t[fa[0]].y);
                    ctx.lineTo(t[fa[1]].x, t[fa[1]].y);
                    ctx.lineTo(t[fa[3]].x, t[fa[3]].y);
                    ctx.lineTo(t[fa[2]].x, t[fa[2]].y);

                    ctx.closePath();
                    ctx.fill();

                }
                //  throw "break";

                // ctx.drawImage(state.texture, t[0].x, t[0].y, t[3].x - t[0].x, t[3].y - t[0].y);
                //ctx.fillStyle = "rgb(255,0,0)";
                //ctx.beginPath();

                //ctx.moveTo(t[0].x, t[0].y);
                //ctx.lineTo(t[1].x, t[1].y);
                //ctx.lineTo(t[3].x, t[3].y);
                //ctx.lineTo(t[2].x, t[2].y);
                //ctx.lineTo(t[0].x, t[0].y);
                //ctx.closePath();
                //ctx.fill();
            }

            this.state.angle += 0.03;

        }).setState({
            d: 100,
            angle: 0.09,
            texture: generateTexture(),
            m: buildings(1000),
            c: colors
    });

        engine.addEntity(sea);

     // engine.start();

    });

    window.onerror = function(err) {
        engine.start();
    };

</script>

</body>
</html>
