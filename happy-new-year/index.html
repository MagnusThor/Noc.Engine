<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background:#897acc;
        }

        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        canvas {
            background: #000;
        }

        #wrapper {
            position: absolute;
            margin-left: auto;
            margin-right: auto;
            width: 720px;
            height: 405px;
            padding: 0;
            left: 50%;
            top: 50%;
           margin:-200px 0 0 -360px;
        }

        #time {
            z-index: 1050;
            position: absolute;
            left: 1em;
            width: 200px;
            top: 1em;
            background: #ff0000;
            color: #ffffff;
            height: 20px;
            padding: 10px;
            display: none;
        }

        #freq {
            z-index: 1050;
            position: absolute;
            left: 1em;
            width: 200px;
            bottom: 1em;
            background: #ff00ff;
            color: #ffffff;
            height: 20px;
            padding: 10px;
            display: none;
        }

        .hide {
            display: none;
        }
    </style>
</head>
<body>
    <div id="time"></div><div id="freq" class="hide"></div>
    <div id="wrapper">
        <canvas id="surface" width="720" height="405"></canvas>
    </div>


    <script src="../src/noc.engine.latest.js"></script>
    <script src="../libs/sid/scriptProcessor.js"></script>
    <script src="../libs/sid/tinysid.js"></script>
    <script>


    </script>


    <script>



        var engine, landscape, assets, analyzer, currentFreq = 0;


        Particle = function () {


            SCALE = {
                MIN: 15,
                MAX: 30
            };
            SPEED = {
                MIN: 0.2,
                MAX: 5
            };
            ALPHA = {
                MIN: 0.8,
                MAX: 0.9
            };
            SPIN = {
                MIN: 0.001,
                MAX: 0.005
            };
            SIZE = {
                MIN: 0.5,
                MAX: 1.25
            };
            COLORS = [
                '#69D2E7',
                '#1B676B',
                '#BEF202',
                '#EBE54D',
                '#00CDAC',
                '#1693A5',
                '#F9D423',
                '#FF4E50',
                '#E7204E',
                '#0CCABA',
                '#FF006F'
            ];



            function Particle(x1, y1) {
                this.x = x1 != null ? x1 : 0;
                this.y = y1 != null ? y1 : 0;
                this.reset();
            }
            Particle.prototype.reset = function () {
                this.level = 1 + floor(random(4));
                this.scale = random(SCALE.MIN, SCALE.MAX);
                this.alpha = random(ALPHA.MIN, ALPHA.MAX);
                this.speed = random(SPEED.MIN, SPEED.MAX);
                this.color = random(COLORS);
                this.size = random(SIZE.MIN, SIZE.MAX);
                this.spin = random(SPIN.MAX, SPIN.MAX);
                this.band = floor(random(128));
                if (random() < 0.5) {
                    this.spin = -this.spin;
                }
                this.smoothedScale = 0;
                this.smoothedAlpha = 0;
                this.decayScale = 0;
                this.decayAlpha = 0;
                this.rotation = random(2 * Math.PI);
                return this.energy = 0;
            };
            Particle.prototype.move = function () {
                this.rotation += this.spin;
                return this.y -= this.speed * this.level;
            };
            Particle.prototype.draw = function (ctx) {

                var alpha, power, scale;
                power = Math.exp(this.energy);
                scale = this.scale * power;
                alpha = this.alpha * this.energy * 1.5;
                this.decayScale = Math.max(this.decayScale, scale);
                this.decayAlpha = Math.max(this.decayAlpha, alpha);
                this.smoothedScale += (this.decayScale - this.smoothedScale) * 0.3;
                this.smoothedAlpha += (this.decayAlpha - this.smoothedAlpha) * 0.3;
                this.decayScale *= 0.985;
                this.decayAlpha *= 0.975;
                ctx.save();
                ctx.beginPath();
                ctx.translate(this.x + Math.cos(this.rotation * this.speed) * 250, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.smoothedScale * this.level, this.smoothedScale * this.level);
                ctx.moveTo(this.size * 0.5, 0);
                ctx.lineTo(this.size * -0.5, 0);
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                ctx.globalAlpha = this.smoothedAlpha / this.level;
                ctx.strokeStyle = this.color;
                ctx.stroke();

                ctx.restore();
            };
            return Particle;
        }();

        var s = 0;
        var q = 300
        var pos = [];
        for (var i = 0; i < 9; i++) {
            pos.push({
                x: Math.floor((Math.random() * 800) + 1),
                y: Math.floor((Math.random() * 800) + 1)
            });
        }


        // Particle / Pills entity
        var Pills = (function () {
            var ctor = function (start, stop, source, num) {
                var bgAnalyzer = analyzer || source;
                this.particles = [];
                for (i = j = 0, ref = num - 1; j <= ref; i = j += 1) {
                    var x = random(this.width);
                    var y = random(this.height * 2);
                    particle = new Particle(x, y);
                    particle.energy = random(particle.band / 256);
                    this.particles.push(particle);
                };


                this.entity = new Noc.Entity("particles", function (render) {
                    var j, len, particle, ref, results;
                    var ctx = render.ctx;
                    ctx.globalCompositeOperation = 'lighter';
                    var array = new Uint8Array(bgAnalyzer.frequencyBinCount);
                    bgAnalyzer.getByteFrequencyData(array);

                    ref = this.state.particles;
                    var update = function (bands) {
                        for (k = 0, len = ref.length; k < len; k++) {
                            particle = ref[k];
                            particle.energy = bands[particle.band] / 256;
                        }
                    }
                    update(array);


                    for (j = 0, len = ref.length; j < len; j++) {
                        particle = ref[j];
                        if (particle.y < -particle.size * particle.level * particle.scale * 2) {
                            particle.reset();
                            particle.x = random(render.width);
                            particle.y = render.height + particle.size * particle.scale * particle.level;
                        }
                        particle.move();
                        particle.draw(ctx);
                    };

                }, start, start + stop).init({
                    particles: this.particles
                });


            };
            return ctor;
        }

        )();

        var Tree = (function () {
            var deg_to_rad = Math.PI / 180.0;

           


            var ctor = function (start, stop) {


                function drawLine(ctx, x1, y1, x2, y2, brightness) {
                    ctx.strokeStyle = "rgba(255,255,255,0.9)";
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }

                function drawTree(ctx,x1, y1, angle, offset, depth) {
                    if (depth == 9) {
                        var x2 = x1 + (Math.cos(-90 * deg_to_rad) * depth * 8.0);
                        var y2 = y1 + (Math.sin(-90 * deg_to_rad) * depth * 8.0);
                        drawLine(ctx,x1, y1, x2, y2, depth);
                        drawTree(ctx,x2, y2, -90 - offset, offset, depth - 1);
                        drawTree(ctx,x2, y2, -90 + offset, offset, depth - 1);

                    } else if (depth != 0) {
                        var x2 = x1 + (Math.cos(angle * deg_to_rad) * depth * 8.0);
                        var y2 = y1 + (Math.sin(angle * deg_to_rad) * depth * 8.0);
                        drawLine(ctx,x1, y1, x2, y2, depth);
                        drawTree(ctx,x2, y2, angle - offset, offset, depth - 1);
                        drawTree(ctx,x2, y2, angle + offset, offset, depth - 1);
                    }
                };
               
                this.entity = new Noc.Entity("tree", function (renderer,tm,ts) {

                    var ctx = renderer.ctx;

                
                    if (currentFreq > 20) {

                        ctx.beginPath();
                        ctx.lineWidth = 10;
                    drawTree(ctx, renderer.width / 2, renderer.height, 90,currentFreq , (9));
                    ctx.closePath();
                    ctx.stroke();
                    }
                },start,stop);
            };
            return ctor; s
        })();

        /// Plasma entity
        var Plasma = (function () {
            var ctor = function (start, stop) {
                var rad = Math.PI / 180;
                this.entity = new Noc.Entity("plasma", function (renderer) {
                    var state = this.state;
                    var res = state.res;
                    var xd = renderer.width / 48;
                    var yd = renderer.height / 48;

                    var ctx = renderer.ctx;

                    for (var x = 0; x < res; x++) {


                        state.aa += 0.0005 * Math.cos(rad * x * state.a[0]);
                        state.ac += 0.0010 * Math.sin(rad * (res - x) * state.a[2]);


                        for (var y = 0; y < res; y++) {

                            state.ab += 0.001 * Math.cos(rad * y * state.a[1]);
                            state.ad += 0.001 * Math.sin(rad * (res - y) * state.a[3]);

                            var h = x * 8 * Math.sin(rad * (state.aa + state.ab) * state.a[4]),
                                j = y * 8 * Math.cos(rad * (state.ac + state.ad) * state.a[5]),
                                k = (x * state.a[0] + y * state.a[1]) * 32 * Math.sin(rad * ((res - x) * h + (y - res) * h) * state.a[2] / 720),
                                l = (res * state.a[3] - x * state.a[3] + (res * state.a[4] - y * state.a[4])) * 32 * Math.sin(rad * (x * h + y * j) * state.a[5] / 720);

                            h = 48 * Math.cos(rad * h) + 42 * Math.cos(rad * j);
                            state.cr = 128 + Math.ceil(42 * Math.cos(rad * k) + h);
                            state.cg = 128 + Math.ceil(42 * Math.cos(rad * l) + h);
                            state.cb = Math.ceil((state.cr + state.cg) / 2 - h * 2);

                            ctx.fillStyle = 'rgb(' + state.cr + ',' + state.cg + ',' + state.cb + ')';
                            ctx.fillRect(y * xd, x * yd, xd, yd);

                        }

                    }

                }, start, stop).init(
                    {
                        res: 48,
                        aa: 0,
                        ab: 0,
                        ac: 0,
                        ad: 0,
                        cr: 16,
                        cg: 128,
                        cb: 128,
                        a: (function (count) {
                            var res = [];
                            for (var i = 0; i < (count | 256) ; i++) {
                                res[i] = Math.ceil(Math.random(0, 1) * 3 + 1);
                            }
                            return res;
                        })()

                    });


            };
            return ctor;

        })();






        // TextFade entity
        var TextFade = (function () {
            var ctor = function (start, stop) {
                this.entity = new Noc.Entity("fade", function (frame, frameTime, totalTime) {
                    var ctx = frame.ctx;
                    var state = this.state;
                    var alpha = state.alpha;
                    var text = state.textBlocks[state.p];
                    var width = frame.width;
                    var height = frame.height;
                    ctx.font = "bold " + state.alpha * (500) + currentFreq + "px Arial";
                    ctx.fillStyle = "rgba(255, 255, 255, " + alpha + ")";
                    ctx.fillText(text, width / 2 -
                        (ctx.measureText(text).width) / 2
                        , height / 2 + (state.alpha * (500 / 2)));
                    state.alpha -= frameTime * currentFreq / 200;
                    if (state.p < state.textBlocks.length - 1) {
                        if (state.alpha < 0) {
                            state.alpha = 1.0;
                            state.p++
                        }
                    }
                }, start, stop).setState({
                    alpha: 1.0,
                    f: 0.4,
                    p: 0,
                    textBlocks: ["YO!!!!", "BAGZY", "AND", "PANTALOON", "JUST", "WANT", "TO", "SAY", "HAPPY", "NEW", "YEAR"]
                });
            };
            return ctor;
        })();





        document.addEventListener("DOMContentLoaded", function () {


            // load the textures.
            // TODO: should use the Perlin Noise lib to generate heightmap instad
            assets = new Noc.Assets({
                images: ["assets/hm.jpg", "assets/tex03.jpg", "assets/scroller-1.png", "assets/happy-new.jpg"]
            }, function () {

                heightmap = imageDataToArrayR(assets.getImageData("assets/hm.jpg"));
                texture = assets.getImageData("assets/tex03.jpg");
                main();
            });



            // story
            var timeLine = {

                trees: {
                    start: 1,
                    stop:20000,
                },

                strobe: {
                    start: 20000,
                    stop: 41000,
                },
                fade: {
                    start: 25000,
                    stop: 61000
                },
                scroller: {
                    start: 50500,
                    stop: 70000,
                },
                plasma: {
                    start: 70000,
                    stop: 90000
                },
                particles: {
                    start: 60000,
                    stop: 40000,
                },
                landscape: {
                    start: 90000,
                    stop: 70000
                }
                , happyNew: {
                    start: 80000 + 6000,
                    stop: 100000

                },
            }

            engine = new Noc.Engine("#surface", null, $("#wrapper"));


            engine.onFrame = function (tm, timer) {
                //  console.log(arguments);
                document.querySelector("#time").textContent = (tm / 1000).toFixed(2);//.elapsed;

                // is there an analyzer?
                if (analyzer) {
                    var array = new Uint8Array(analyzer.frequencyBinCount);
                    analyzer.getByteFrequencyData(array);
                    var freq = floor((array.reduce(function (a, b) { return a + b })) / array.length);
                    if (freq > 50 & freq < 60) {

                        document.querySelector("#freq").textContent = floor(freq);
                        document.querySelector("#freq").classList.remove("hide");
                    } else {
                        document.querySelector("#freq").classList.add("hide");
                    }

                    currentFreq = freq;


                };

            };
            document.querySelector("#time").addEventListener("click", function () {
                engine.stop();
            });

            var HappyNew = (function () {

                var ctor = function (start, stop, image) {
                    this.entity = new Noc.Entity("edwin", function (renderer) {
                        var ctx = renderer.ctx;
                        var img = this.state.img;
                        ctx.drawImage(img, renderer.width / 2 - (img.width / 2), renderer.height / 2 - (img.height) / 2, img.width, img.height);


                    }, start, stop).setState({
                        img: image
                    });
                };
                return ctor;
            })();


            // Scroller entiry
            var Scroller = (function () {
                var ctor = function (start, stop, image) {
                    this.entity = new Noc.Entity("oldScroller", function (renderer) {
                        var img = this.state.image;
                        var ctx = renderer.ctx;
                        ctx.drawImage(img, renderer.width - Math.abs(this.state.vx), renderer.height - (image.height - 10), img.width, img.height);
                        if (Math.abs(this.state.vx) > (img.width * 2)) {
                            this.state.vx = 0;
                        }
                        this.state.vx -= 5;
                    }, start, stop).setState({
                        vx: 0,
                        image: image
                    });
                };
                return ctor;
            })();


            var Strobe = (function () {

                var ctor = function (start, stop, num) {
                    var arrPos = [];


                    for (var i = 0; i < num; i++) {
                        arrPos.push({
                            x: random(1440),
                            y: random(900)
                        });
                    };

                    this.entity = new Noc.Entity("stobe", function (renderer, ts, tm) {
                        var ctx = renderer.ctx;
                        var state = this.state;
                        if (!analyzer) return;
                        var width = renderer.width;
                        var height = renderer.height;
                        ctx.globalAlpha = 0.5;
                        //  if ((currentFreq > 50 && currentFreq < 80)) {

                        for (var i = 0 ; i < state.strobes - 1; i++) {
                            var p = state.strobePos[i];
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, currentFreq * 2, 0, 2 * Math.PI);
                            ctx.fillStyle = "rgba(255,255,0,0.03)";
                            ctx.fill();
                        };
                        //  };



                    }, start, stop).setState({
                        strobes: num,
                        strobePos: arrPos
                    });;
                };

                return ctor;

            })();



            var Landscape = (function () {

                var ctor = function (start, stop) {
                    // double buffer
                    offscreenCanvas = document.createElement('canvas');
                    offscreenCanvas.width = 160;
                    offscreenCanvas.height = 100;;
                    offscreenContext = offscreenCanvas.getContext("2d");

                    this.entity = new Noc.Entity("landscape", function (render, tfs, tm) {
                        var onscreenContext = render.ctx;
                        var offscreenContext = this.state.buffers[0].context;
                        var frame = this.state.frame;
                        var constants = this.state.constants;
                        var position = this.state.position;

                        offscreenContext.fillStyle = "rgba(" + constants.color.fog[0] + "," + constants.color.fog[1] + "," + constants.color.fog[2] + ",0.4)";
                        offscreenContext.fillRect(0, 0, constants.screen.width, constants.screen.height);

                        frame = offscreenContext.getImageData(0, 0, constants.screen.width, constants.screen.height);

                        var image = frame.data;

                        var doff = constants.pov.depthOfField / 1;
                        var c1 = constants.screen.height / 2;
                        var c2 = constants.screen.distance * position.z;

                        for (var i = 0; i < constants.screen.width; i++) {
                            var orientation = position.a - constants.pov.horizontalOpening * (1 - i * 2 / constants.screen.width);
                            var progression = { x: Math.cos(orientation), y: Math.sin(orientation) };

                            var distanceProbed = 0;
                            var screenProjectedTop = 0;
                            var oldHeight = 0;
                            var oldRenderCache = false;
                            var summit = false;

                            while (distanceProbed < constants.pov.depthOfField && screenProjectedTop < constants.screen.height) {

                                distanceProbed += (distanceProbed < doff) ? 2 : (distanceProbed < 2 * doff) ? 4 : (distanceProbed < 3 * doff) ? 8 : 16;
                                var probe = {
                                    x: Math.abs(Math.ceil(position.x + distanceProbed * progression.x)),
                                    y: Math.abs(Math.ceil(position.y + distanceProbed * progression.y))
                                };
                                var dataIndex = heightmap.width * (probe.y % heightmap.height) + (probe.x % heightmap.width);


                                var height = heightmap.data[dataIndex];
                                if (height < oldHeight) {
                                    oldHeight = height;
                                    continue;
                                }
                                oldHeight = height;

                                var projectedHeight = Math.min(Math.ceil(c1 - (c2 - constants.screen.distance * height) / distanceProbed), constants.screen.height);


                                if (projectedHeight > screenProjectedTop) {
                                    var textureDataIndex = (texture.width * (probe.y % texture.height) + (probe.x % texture.width)) * 4;
                                    var textureCache = [texture.data[textureDataIndex], texture.data[textureDataIndex + 1], texture.data[textureDataIndex + 2]];

                                    var fillGoal = Math.max(constants.screen.height - projectedHeight, 0);
                                    var fogFactor = Math.min(distanceProbed, constants.pov.depthOfField) / constants.pov.depthOfField;
                                    var invFogFactor = (1 - fogFactor);


                                    var renderCache = {
                                        r: invFogFactor * textureCache[0] + fogFactor * constants.color.fog[0],
                                        g: invFogFactor * textureCache[1] + fogFactor * constants.color.fog[1],
                                        b: invFogFactor * textureCache[2] + fogFactor * constants.color.fog[2]
                                    };
                                    oldRenderCache = renderCache;
                                    // render
                                    for (var j = (constants.screen.height - screenProjectedTop) ; j > fillGoal; j--) {
                                        image[(i + j * constants.screen.width) * 4] = Math.ceil(renderCache.r);
                                        image[(i + j * constants.screen.width) * 4 + 1] = Math.ceil(renderCache.g);
                                        image[(i + j * constants.screen.width) * 4 + 2] = Math.ceil(renderCache.b);
                                        image[(i + j * constants.screen.width) * 4 + 3] = 255;
                                    }
                                    screenProjectedTop = projectedHeight;
                                    summit = false;
                                } else if (screenProjectedTop > projectedHeight) {
                                    summit = true;
                                }
                            }

                            // 3) if the top is lower than the top of the screen we fill it
                            if (position.antialiasing) {
                                if ((constants.screen.height - screenProjectedTop + 1) >= 0) {
                                    var j = (i + (constants.screen.height - screenProjectedTop + 1) * constants.screen.width) * 4;
                                    image[j] = Math.ceil(0.5 * image[j] + 0.5 * constants.color.fog[0]);
                                    image[j + 1] = Math.ceil(0.5 * image[j + 1] + 0.5 * constants.color.fog[1]);
                                    image[j + 2] = Math.ceil(0.5 * image[j + 2] + 0.5 * constants.color.fog[2]);
                                }
                            }
                        }
                        frame.data = image;
                        offscreenContext.putImageData(frame, 0, 0);
                        onscreenContext.drawImage(offscreenCanvas, 0, 0, render.width, render.height);
                        position.y += 5;





                    }, start, stop).init(
                    {

                        buffers: [{
                            canvas: offscreenCanvas,
                            context: offscreenContext
                        }],
                        frame: offscreenContext.getImageData(0, 0, 160, 100),

                        constants:
                    {

                        highres: true,
                        screen: {
                            height: 100,
                            width: 160,
                            zoom: 8
                        },

                        pov: {
                            verticalOpening: 0.4,
                            depthOfField: 1000
                        },

                        color: {
                            fog: [250, 250, 250, 0.1]
                        },

                        init: function () {

                            this.pov.horizontalOpening = Math.atan(this.pov.verticalOpening) * this.screen.width / this.screen.height;
                            this.screen.distance = this.screen.width / 2 / Math.tan(this.pov.horizontalOpening);
                        }
                    },
                        position: {
                            x: 450,
                            y: 0,
                            z: 200,
                            a: Math.PI / 2,
                            antialiasing: false
                        },
                    });
                }
                return ctor;

            })();

            var main = function () {

                ScriptNodePlayer.createInstance(new SIDBackendAdapter(), "", [], true, function () { }, function () {
                    this.play();
                    var that = this; // SID Tune

                    // Make the analyzer node accessable...

                    var tree = new Tree(timeLine.trees.start, timeLine.trees.stop);


                    tree.entity.onLifetimeend = function () {
                        engine.removeEntity(this);
                    };

                    engine.addEntity(tree.entity);


                    analyzer = that._analyzerNode

                    var outro = new HappyNew(timeLine.happyNew.start, timeLine.happyNew.stop, assets.getImage("assets/happy-new.jpg"));


                    engine.addEntity(outro.entity);


                    fade = new TextFade(timeLine.fade.start, timeLine.fade.stop);
                    fade.entity.onLifetimeend = function () {
                        engine.removeEntity(this);
                    };

                    strobe = new Strobe(timeLine.strobe.start, timeLine.strobe.stop, 600);


                    strobe.entity.onLifetimeend = function () {
                        engine.removeEntity(this);
                    };

                    engine.addEntity(strobe.entity);
                    engine.addEntity(fade.entity);


               


                    // Set up Scroller
                    var scroller = new Scroller(
                       timeLine.scroller.start, timeLine.scroller.stop,
                        assets.getImage("assets/scroller-1.png"));

                    scroller.entity.onLifetimeend = function () {

                        engine.removeEntity(this);
                    };
                    engine.addEntity(scroller.entity);


                    // Set up plasma
                    plasma = new Plasma(timeLine.plasma.start, timeLine.plasma.stop);
                    plasma.entity.onLifetimeend = function () {
                        engine.removeEntity(this);

                    };
                    engine.addEntity(plasma.entity);


                    // Setup Particles
                    var particleEffect = new Pills(timeLine.particles.start, timeLine.particles.stop, that, 64); // Where that is the SID
                    engine.addEntity(particleEffect.entity);
                    particleEffect.entity.onLifetimeend = function () {
                        engine.removeEntity(this, function () {

                            // Set up Landscape

                            var landscape = new Landscape(timeLine.landscape.start, timeLine.landscape.stop);

                            landscape.entity.onLifetimeend = function () {
                                engine.removeEntity(this);
                            };





                            engine.addEntity(landscape.entity, function () {

                                landscape.entity.state.constants.init();
                            });


                        })

                    };







                    engine.start();


                }, function () {

                });
                ScriptNodePlayer.getInstance().loadMusicFromURL("So-Phisticated_III_part_1.zip", {
                    basePath: "assets/sid/"
                }, function () { });


                //    });



            }

            // when the sig is loaded. add the spectrum





        });

        window.onerror = function () {
            engine.stop();
        };

    </script>

</body>
</html>
